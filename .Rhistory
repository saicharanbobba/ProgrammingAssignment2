## matrix inverse is a complex computation and hence calculating its value repeatedly is a
## long process so its better to cache the inverse of a matrix rather than calculating it
## repeatedly.
##
## this function creates a special matrix object that can cache its inverse value
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinverse <- function(inverse) i <<- inverse
getinverse <- function() i
list(set = set,
get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
## this function calculates the inverse of special matrix returned by makecache matrix
## above . if inverse had already been calculated and no change has occured to the matrix
## then cachesolve should retrieve inverse value from cache
cacheSolve <- function(x, ...) {
i <- x$getinverse()
if (!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinverse(i)
i
## Return a matrix that is the inverse of 'x'
}
testmatrix<- matrix(5:21,4,4)
testmatrix <-matrix(5:20,4,4)
CacheMatrix <- makeCacheMatrix(TestMatrix)
CacheMatrix$getMatrix()
CacheMatrix$getMatrix()
CacheMatrix <- makeCacheMatrix(TestMatrix)
CacheMatrix$getMatrix()
CacheMatrix$getInverse()
cacheSolve(CacheMatrix)
cacheSolve(CacheMatrix)
## matrix inverse is a complex computation and hence calculating its value repeatedly is a
## long process so its better to cache the inverse of a matrix rather than calculating it
## repeatedly.
##
## this function creates a special matrix object that can cache its inverse value
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinverse <- function(inverse) i <<- inverse
getinverse <- function() i
list(set = set,
get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
## this function calculates the inverse of special matrix returned by makecache matrix
## above . if inverse had already been calculated and no change has occured to the matrix
## then cachesolve should retrieve inverse value from cache
cacheSolve <- function(x, ...) {
i <- x$getinverse()
if (!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinverse(i)
i
## Return a matrix that is the inverse of 'x'
}
TestMatrix <- matrix(1:4,2,2)
testmatrix
CacheMatrix <- makeCacheMatrix(TestMatrix)
CacheMatrix$get()
CacheMatrix$getInverse()
CacheMatrix$getinverse()
cacheSolve(CacheMatrix)
## matrix inverse is a complex computation and hence calculating its value repeatedly is a
## long process so its better to cache the inverse of a matrix rather than calculating it
## repeatedly.
##
## this function creates a special matrix object that can cache its inverse value
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinverse <- function(inverse) i <<- inverse
getinverse <- function() i
list(set = set,
get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
## this function calculates the inverse of special matrix returned by makecache matrix
## above . if inverse had already been calculated and no change has occured to the matrix
## then cachesolve should retrieve inverse value from cache
cacheSolve <- function(x, ...) {
i <- x$getinverse()
if (!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinverse(i)
i
## Return a matrix that is the inverse of 'x'
}
TestMatrix <- matrix(5:21,4,4)
TestMatrix
CacheMatrix <- makeCacheMatrix(TestMatrix)
CacheMatrix$get()
CacheMatrix$getinverse()
cacheSolve(CacheMatrix)
cacheSolve(CacheMatrix)
getinverse <- function() i
## matrix inverse is a complex computation and hence calculating its value repeatedly is a
## long process so its better to cache the inverse of a matrix rather than calculating it
## repeatedly.
##
## this function creates a special matrix object that can cache its inverse value
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinverse <- function(inverse) i <<- inverse
getinverse <- function() i
list(set = set,
get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
## this function calculates the inverse of special matrix returned by makecache matrix
## above . if inverse had already been calculated and no change has occured to the matrix
## then cachesolve should retrieve inverse value from cache
cacheSolve <- function(x, ...) {
i <- x$getinverse()
if (!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinverse(i)
i
## Return a matrix that is the inverse of 'x'
}
TestMatrix <- matrix(c(2,3,5,1,3,7,4,5,6,8,0,0,4,5,6,0),4,4)
TestMatrix
CacheMatrix <- makeCacheMatrix(TestMatrix)
CacheMatrix$get()
CacheMatrix$getinverse()
cacheSolve(CacheMatrix)
cacheSolve(CacheMatrix)
